//File: test_mult_add_vec.svp
//This module performs segmented multiplication and accumulation.
//Author: Vinh Nguyen
//Attributions: Original multiply adder code from garnet (https://github.com/StanfordAHA/garnet/).
//Partial product generation taken from Synopsys DesignWare Libraries (DW02_multp.v).
//; my $use_mad = parameter(Name=>'use_mad', Val=>1, List=>[1, 0],
//;                               Doc=>"Use MAD or simple MULT");
// New parameter added. Needs to be propagated to the relevant files to compile in Genesis (?)
//; my $max_vec_sz = parameter(Name=>'max_vec_sz', Val=>4, List=>[4, 2, 1],
//;                               Doc=>"Maximum number of elements allowed in segmented mult");
module  `mname`  #(
  parameter DataWidth = 16,
  parameter MaxVecSz = 4
) (
  input                  is_signed,
  input  [1:0]           vec_mode, /*one-hot*/
  input  [DataWidth-1:0] a,
  input  [DataWidth-1:0] b,

//; if ($use_mad) {
  input  [DataWidth-1:0] c,
//;}

  output logic [2*DataWidth-1:0] res,
  output logic                   c_out
);
//Does this work?
//; for (my $i = 1; $i <= $max_vec_sz; $i = $i*2) {
	wire signed [2*DataWidth/`$i`:0] sum_pp_`$i`[0:`$i`];
//; }
//DesignWare Code-----------------------------------------------------------------------------

localparam npp  = ((DataWidth/2) + 2);
localparam xdim = (DataWidth+DataWidth+1);
localparam bsxt = (DataWidth+1);

//-----------------------------------------------------------------------------
reg   [xdim-1 : 0]  pp_array [0 : npp-1];
reg   [xdim-1 : 0]	tmp_OUT0, tmp_OUT1;
wire  [DataWidth+2 : 0]	a_padded;
wire  [xdim-1 : 0]	b_padded;
wire  [xdim-DataWidth-1 : 0]	temp_padded;
wire  			a_sign, b_sign, out_sign;
wire  [out_width-1:0]   out0_fixed_cs, out1_fixed_cs;
wire  signed [DataWidth : 0]      a_signed;
wire  signed [DataWidth : 0]      b_signed;
wire  signed [out_width-1:0] product;
//-----------------------------------------------------------------------------
//Here, a is the multiplier and b is the multiplicand.
  assign a_sign = is_signed & a[DataWidth-1];
  assign b_sign = is_signed & b[DataWidth-1];
  assign a_padded = {a_sign, a_sign, a, 1'b0};
  assign temp_padded = {bsxt{b_sign}};
  assign b_padded = {temp_padded, b};

  always @ (a_padded or b_padded or vec_mode)//vec_mode added.
  begin : mk_pp_array
    reg [xdim-1 : 0] temp_pp_array [0 : npp-1];
    reg [xdim-1 : 0] next_pp_array [0 : npp-1];
    reg [xdim+3 : 0] temp_pp;
    reg [xdim-1 : 0] new_pp;
    reg [xdim-1 : 0] tmp_pp_carry;
    reg [DataWidth+2 : 0] temp_a_padded;
    reg [2 : 0] temp_bitgroup;
    integer bit_pair, pp_count, i;

    temp_pp_array[0] = {xdim{1'b0}};
    for (bit_pair=0 ; bit_pair < npp-1 ; bit_pair = bit_pair+1)
    begin
      temp_a_padded = (a_padded >> (bit_pair*2));
      temp_bitgroup = temp_a_padded[2 : 0];

      case (temp_bitgroup)
        3'b000, 3'b111 :
          temp_pp = {xdim{1'b0}};
        3'b001, 3'b010 :
          temp_pp = b_padded;
        3'b011 :
          temp_pp = b_padded << 1;
        3'b100 :
          temp_pp = (~(b_padded << 1) + 1);
        3'b101, 3'b110 :
          temp_pp =  ~b_padded + 1;
        default : temp_pp = {xdim{1'b0}};
      endcase

      temp_pp = temp_pp << (2 * bit_pair);
      new_pp = temp_pp[xdim-1 : 0];
      temp_pp_array[bit_pair+1] = new_pp;
    end
	//TODO
	//zero-out the correct bit ranges for the given vec_mode for each partial product. Accumulate into each of the output arrays for each vector mode
	//Perform accumulation if MAC mode is on (incorporate code below up here)
	//Mux appropriate output array to the output port
  end
//-------Old MAC code starts:
//; if ($use_mad) {

/*
  logic signed [2*(DataWidth+1)  :0] mult_res_signed;
  logic signed [2*(DataWidth+1)-1:0] res_signed;
  logic [1:0] nc_res_signed_msb;
  assign nc_res_signed_msb = res_signed[2*(DataWidth+1)-1:2*(DataWidth+1)-2];


  logic signed [DataWidth:0] a_ext;
  logic signed [DataWidth:0] b_ext;
  logic signed [2*(DataWidth+1)-1:0] c_ext;

  assign a_ext = $signed({is_signed & a[DataWidth-1], a});
  assign b_ext = $signed({is_signed & b[DataWidth-1], b});
  assign c_ext = $signed({ {(DataWidth+1){is_signed & c[DataWidth-1]}}, c});

  assign mult_res_signed = (a_ext*b_ext)+c_ext;
  assign {c_out, res_signed} = $unsigned(mult_res_signed);

  assign res = res_signed[2*DataWidth-1:0];*/
//;} else {
/*
  logic signed [2*(DataWidth+1)-1:0] res_signed;
  logic [1:0] nc_res_signed_msb;
  assign nc_res_signed_msb = res_signed[2*(DataWidth+1)-1:2*(DataWidth+1)-2];

  logic signed [DataWidth:0] a_ext;
  logic signed [DataWidth:0] b_ext;

  assign a_ext = $signed({is_signed & a[DataWidth-1], a});
  assign b_ext = $signed({is_signed & b[DataWidth-1], b});

  assign res_signed = a_ext*b_ext;

  assign res = $unsigned(res_signed[2*DataWidth-1:0]);
  assign c_out = 1'b0;*/
//;}

endmodule
